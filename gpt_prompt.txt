write a C++ code that receives three files:

`vertices.csv`:
```
coord00, coord01, ..., coord0n
coord10, coord11, ..., coord1n
...
coordm0, coordm1, ..., coordmn
```

`targets.csv`:
```
target0
target1
...
targetm
```

`edges.csv`:
```
vertex_a, vertex_b
vertex_c, vertex_d
...
```

none of those have headers or row names, but their content data is consistent. `vertex_n` is an integer which value is the line in `vertices.csv` that contains the coordinates of this vertex. The coordinates are separated by commas. each line of `vertices.csv` is a vertex in the graph. each line of `targets.csv` is the class of the corresponding vertex in `vertices.csv`. `edges.csv` contains the edges of the graph, where each line is an edge that connects two vertices. lines are 0-indexed.

as an example, supose

`vertices.csv`:
```
0.1, 1.0, 3.2, 9.1
0.2, 1.1, 3.3, 9.2
0.3, 1.2, 3.4, 9.3
0.4, 1.3, 3.5, 9.4
```

`targets.csv`:
```
0
1
0
1
```

`edges.csv`:
```
0, 1
1, 3
2, 3
```

this means that the graph has 4 vertices and 3 edges, where the first edge connects vertex 0 to vertex 1, the second edge connects vertex 1 to vertex 3 and the third edge connects vertex 2 to vertex 3. the class of vertex 0 is 0, the class of vertex 1 is 1, the class of vertex 2 is 0 and the class of vertex 3 is 1.

this code needs to use vertex degree-based filtering technique to produce new files in which outliers are removed

This filter is defined by Ĝr(x_i) = {for_all(x_j) contained in Gr(x_i) | y_j = y_i}

where Gr(x_i) is the degree of vertex x_i and Ĝr(x_i) is the degree of vertex x_i minus the number of vertices that are not in the same class as x_i

all vertices of G that have q(x_i) smaller than the class threshold are removed from the graph, where

q(x_i) = Ĝr(x_i) / Gr(x_i)

and the class threshold, t_class, is the average of q(x_i) for all vertices in the same class as x_i

t_class = sum(q(x_i) contained in Q_class) / |Q_class|

where Q_class is the set of q(x_i) for all vertices in the same class as x_i

----------------------------------------------------------------------------------------

consider the following files from the current dir {workspaece}:

```
.
├── data
│   ├── ilpd
│   │   ├── ILPD.csv
│   └── iris
│       ├── iris.csv
├── golden
│   ├── GabrielGraph
│   │   ├── multiVariableGabrielGraph
│   │   ├── output
│   │   │   ├── ILPD.csv
│   │   │   └── iris.csv
│   ├── LowDegreeVerticesFilter
│   │   ├── lowDegreeVerticesFilter
│   │   ├── output
│   │   │   ├── ILPD-filtered.csv
│   │   │   ├── ILPD-filtered.csv
└── visualize.py
```

`data`:
```
feature0_0, feature0_1, ..., feature0_n, class0
feature1_0, feature1_1, ..., feature1_n, class1
...
featurem_0, featurem_1, ..., featurem_n, classm
```

`graph`:
```
vertex0_id, |, feature0_0, feature0_1, ..., feature0_n, |, cluster0_id, |, adjacent_vertex0_0, adjacent_vertex0_1, ..., adjacent_vertex0_m
vertex1_id, |, feature1_0, feature1_1, ..., feature1_n, |, cluster1_id, |, adjacent_vertex1_0, adjacent_vertex1_1, ..., adjacent_vertex1_m
...
vertexk_id, |, featurek_0, featurek_1, ..., featurek_n, |, clusterk_id, |, adjacent_vertexk_0, adjacent_vertexk_1, ..., adjacent_vertexk_m
```

`vertexV_id` is an integer that identifies the vertex in the graph. each `featureV_i` is the i-dimension coordinate of the vertex V. `clusterV_id` is the class of the vertex V. `adjacent_vertexV_j` is the id of the vertex that is adjacent to vertex V.

none of those have headers or row names, but their content data is consistent.

as an example, suppose
```

`data.csv`:
```
0.1, 1.0, 3.2, 9.1, 0
0.2, 1.1, 3.3, 9.2, 1
0.3, 1.2, 3.4, 9.3, 0
0.4, 1.3, 3.5, 9.4, 1
```

`graph.csv`:
```
0, |, 0.1, 1.0, 3.2, 9.1, |, 0, |, 1, 3
1, |, 0.2, 1.1, 3.3, 9.2, |, 1, |, 0, 3
2, |, 0.3, 1.2, 3.4, 9.3, |, 0, |, 3
3, |, 0.4, 1.3, 3.5, 9.4, |, 1, |, 0, 1, 2
```

this means that the graph has 4 vertices and 2 clusters, where the first cluster has 2 vertices and the second cluster has 2 vertices. the first vertex has coordinates (0.1, 1.0, 3.2, 9.1) and is adjacent to the second and fourth vertices. the second vertex has coordinates (0.2, 1.1, 3.3, 9.2) and is adjacent to the first and fourth vertices. the third vertex has coordinates (0.3, 1.2, 3.4, 9.3) and is adjacent to the fourth vertex. the fourth vertex has coordinates (0.4, 1.3, 3.5, 9.4) and is adjacent to the first, second and third vertices.

write a python3 code to:
- receive, upon call, number of dimensions (2 or 3), number of classes, number of vertices and spread factor
- generates synthetic n-dimensional data to meet the requested number of classes
- save this data on a new directory under `data`
- display the data
- run the Gabriel Graph program over the data
- display the constructed graph
- run the Low Degree Vertices Filter over the data
- display the filtered graph

the naming and structure format must be kept

`multiVariableGabrielGraph` usage: `multiVariableGabrielGraph <path_to_data_csv>`
`multiVariableGabrielGraph` output: `{workspaece}/golden/GabrielGraph/output/<graphname>.csv`

`lowDegreeVerticesFilter` usage: `lowDegreeVerticesFilter <path_to_graph_csv>`
`lowDegreeVerticesFilter` output: `{workspaece}/golden/LowDegreeVerticesFilter/output/<graphname>-filtered.csv`

----------------------------------------------------------------------------------------
