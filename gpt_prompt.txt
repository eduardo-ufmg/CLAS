consider the following files from the current dir {workspace_root}:

```
.
├── data
│   ├── ilpd
│   │   ├── ilpd.csv
│   └── iris
│       ├── iris.csv
├── golden
│   ├── GabrielGraph
│   │   ├── multiVariableGabrielGraph
│   │   ├── output
│   │   │   ├── ilpd.csv
│   │   │   └── iris.csv
│   ├── LowDegreeVerticesFilter
│   │   ├── lowDegreeVerticesFilter
│   │   ├── output
│   │   │   ├── ilpd-filtered.csv
│   │   │   ├── iris-filtered.csv
└── visualize.py
```

`data`:
```
feature0_0, feature0_1, ..., feature0_n, class0
feature1_0, feature1_1, ..., feature1_n, class1
...
featurem_0, featurem_1, ..., featurem_n, classm
```

`graph`:
```
vertex0_id, |, feature0_0, feature0_1, ..., feature0_n, |, cluster0_id, |, adjacent_vertex0_0, adjacent_vertex0_1, ..., adjacent_vertex0_m
vertex1_id, |, feature1_0, feature1_1, ..., feature1_n, |, cluster1_id, |, adjacent_vertex1_0, adjacent_vertex1_1, ..., adjacent_vertex1_m
...
vertexk_id, |, featurek_0, featurek_1, ..., featurek_n, |, clusterk_id, |, adjacent_vertexk_0, adjacent_vertexk_1, ..., adjacent_vertexk_m
```

`vertexV_id` is an integer that identifies the vertex in the graph. each `featureV_i` is the i-dimension coordinate of the vertex V. `clusterV_id` is the class of the vertex V. `adjacent_vertexV_j` is the id of the vertex that is adjacent to vertex V.

none of those have headers or row names, but their content data is consistent.

as an example, suppose
```

`data.csv`:
```
0.1, 1.0, 3.2, 9.1, 0
0.2, 1.1, 3.3, 9.2, 1
0.3, 1.2, 3.4, 9.3, 0
0.4, 1.3, 3.5, 9.4, 1
```

`graph.csv`:
```
0, |, 0.1, 1.0, 3.2, 9.1, |, 0, |, 1, 3
1, |, 0.2, 1.1, 3.3, 9.2, |, 1, |, 0, 3
2, |, 0.3, 1.2, 3.4, 9.3, |, 0, |, 3
3, |, 0.4, 1.3, 3.5, 9.4, |, 1, |, 0, 1, 2
```

this means that the graph has 4 vertices and 2 clusters, where the first cluster has 2 vertices and the second cluster has 2 vertices. the first vertex has coordinates (0.1, 1.0, 3.2, 9.1) and is adjacent to the second and fourth vertices. the second vertex has coordinates (0.2, 1.1, 3.3, 9.2) and is adjacent to the first and fourth vertices. the third vertex has coordinates (0.3, 1.2, 3.4, 9.3) and is adjacent to the fourth vertex. the fourth vertex has coordinates (0.4, 1.3, 3.5, 9.4) and is adjacent to the first, second and third vertices.

write a python3 code to:
- receive, upon call, number of dimensions (2 or 3), number of classes, number of vertices and spread factor
- generates synthetic n-dimensional data to meet the requested number of classes
- save this data on a new directory under `data`
- plot the data
- run the Gabriel Graph program over the data
- plot the constructed graph
- run the Low Degree Vertices Filter over the data
- plot the filtered graph

the naming and structure format must be kept

`multiVariableGabrielGraph` usage: `{workspace_root}/golden/GabrielGraph/multiVariableGabrielGraph {workspace_root}/data/synthetic/synthetic.csv`
`multiVariableGabrielGraph` output: `{workspace_root}/golden/GabrielGraph/output/synthetic.csv`

`lowDegreeVerticesFilter` usage: `{workspace_root}/golden/LowDegreeVerticesFilter/lowDegreeVerticesFilter {workspace_root}/golden/GabrielGraph/output/synthetic.csv`
`lowDegreeVerticesFilter` output: `{workspace_root}/golden/LowDegreeVerticesFilter/output/synthetic-filtered.csv`

----------------------------------------------------------------------------------------

```
void filterVertices(ClusterMap& clusters, double deviationFactor)
{
  for (auto& [key, cluster] : clusters) {
    // Avoid division by zero if there are no vertices.
    if (cluster.vertices.empty()) {
      continue;
    }

    for (auto& vertex : cluster.vertices) {
      unsigned degree = vertex.adjacents.size();
      unsigned sameClusterDegree = 0;

      if (degree == 0) {
        vertex.q = 0.0;
        continue;
      }

      for (const auto& adjacent : vertex.adjacents) {
        if (std::find(cluster.vertices.begin(), cluster.vertices.end(), *adjacent) != cluster.vertices.end()) {
          sameClusterDegree ++;
        }
      }

      vertex.q = static_cast<double>(sameClusterDegree) / degree;

    }

    // Recompute quality metrics for the cluster.
    cluster.Q.magnitude = cluster.vertices.size();

    cluster.Q.sum_q = std::accumulate(cluster.vertices.begin(), cluster.vertices.end(), 0.0, [](double sum, const Vertex& v) { return sum + v.q; });

    cluster.averageQuality = cluster.Q.sum_q / cluster.Q.magnitude;

    double sumSquaredDiff = 0.0;

    for (const Vertex& v : cluster.vertices) {
      double diff = v.q - cluster.averageQuality;
      sumSquaredDiff += diff * diff;
    }

    cluster.stdDeviation = std::sqrt(sumSquaredDiff / cluster.Q.magnitude);

    // Update the threshold using the deviationFactor.
    cluster.threshold = cluster.averageQuality - deviationFactor * cluster.stdDeviation;

    // Remove vertices whose q value is less than the threshold.
    cluster.vertices.erase(std::remove_if(cluster.vertices.begin(), cluster.vertices.end(), [&cluster](const Vertex& v) { return v.q < cluster.threshold; }), cluster.vertices.end());

  }
}
```
```
typedef unsigned VertexID_t;

class Vertex
{
public:
  std::vector<double> features;
  std::vector<Vertex*> adjacents;
  VertexID_t id;
  double q;

  bool operator<(const Vertex& other) const;
  bool operator==(const Vertex& other) const;
  bool operator!=(const Vertex& other) const;
};

class QualityMeasure
{
public:
  double sum_q;
  double magnitude;
};

class Cluster
{
public:
  std::vector<Vertex> vertices;
  QualityMeasure Q;
  double threshold;
  double averageQuality;
  double stdDeviation;
};

using ClassType = std::variant<unsigned, std::string>;
typedef std::map<ClassType, Cluster> ClusterMap;
```

The filter is messing with the adjacency lists of the vertices that are not removed. As an example, those are some adjacency lists for the graph, in the format `vertex0_id, |, adjacent_vertex0_0, adjacent_vertex0_1, ..., adjacent_vertex0_m`, before the filter:
```
0, |, 28, 31, 34
1, |, 4, 20, 29, 39
2, |, 9, 26, 42
3, |, 22, 32, 39, 43
4, |, 1, 13, 15, 41
5, |, 17, 23
6, |, 21, 36, 49
7, |, 11, 12, 25, 27
8, |, 30, 46, 87
9, |, 2, 40, 42
10, |, 15, 16, 23, 46
11, |, 7, 29, 39, 43
12, |, 7, 18
13, |, 4, 29, 45
14, |, 22, 35
15, |, 4, 10, 16, 20, 33, 46
```
and after the filter:
```
0, |, 29, 32, 35
1, |, 4, 21, 30, 41
2, |, 10, 27, 44
3, |, 23, 33, 41, 45
4, |, 1, 14, 16, 43
5, |, 18, 24
6, |, 22, 37, 49
7, |, 12, 13, 26, 28
9, |, 2, 42, 44
10, |, 16, 17, 24, 48
11, |, 7, 30, 41, 45
12, |, 7, 19
13, |, 4, 30, 47
14, |, 23, 36
15, |, 4, 11, 17, 21, 34, 48
16, |, 11, 16, 24, 34, 42
```

----------------------------------------------------------------------------------------
