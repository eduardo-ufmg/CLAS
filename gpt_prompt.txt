consider the following files from the current dir {workspace_root}:

```
.
├── data
│   ├── ilpd
│   │   ├── ilpd.csv
│   └── iris
│       ├── iris.csv
├── golden
│   ├── GabrielGraph
│   │   ├── multiVariableGabrielGraph
│   │   ├── output
│   │   │   ├── ilpd.csv
│   │   │   └── iris.csv
│   ├── LowDegreeVerticesFilter
│   │   ├── lowDegreeVerticesFilter
│   │   ├── output
│   │   │   ├── ilpd-filtered.csv
│   │   │   ├── iris-filtered.csv
└── visualize.py
```

`data`:
```
feature0_0, feature0_1, ..., feature0_n, class0
feature1_0, feature1_1, ..., feature1_n, class1
...
featurem_0, featurem_1, ..., featurem_n, classm
```

`graph`:
```
vertex0_id, |, feature0_0, feature0_1, ..., feature0_n, |, cluster0_id, |, adjacent_vertex0_0, adjacent_vertex0_1, ..., adjacent_vertex0_m
vertex1_id, |, feature1_0, feature1_1, ..., feature1_n, |, cluster1_id, |, adjacent_vertex1_0, adjacent_vertex1_1, ..., adjacent_vertex1_m
...
vertexk_id, |, featurek_0, featurek_1, ..., featurek_n, |, clusterk_id, |, adjacent_vertexk_0, adjacent_vertexk_1, ..., adjacent_vertexk_m
```

`vertexV_id` is an integer that identifies the vertex in the graph. each `featureV_i` is the i-dimension coordinate of the vertex V. `clusterV_id` is the class of the vertex V. `adjacent_vertexV_j` is the id of the vertex that is adjacent to vertex V.

none of those have headers or row names, but their content data is consistent.

as an example, suppose
```

`data.csv`:
```
0.1, 1.0, 3.2, 9.1, 0
0.2, 1.1, 3.3, 9.2, 1
0.3, 1.2, 3.4, 9.3, 0
0.4, 1.3, 3.5, 9.4, 1
```

`graph.csv`:
```
0, |, 0.1, 1.0, 3.2, 9.1, |, 0, |, 1, 3
1, |, 0.2, 1.1, 3.3, 9.2, |, 1, |, 0, 3
2, |, 0.3, 1.2, 3.4, 9.3, |, 0, |, 3
3, |, 0.4, 1.3, 3.5, 9.4, |, 1, |, 0, 1, 2
```

this means that the graph has 4 vertices and 2 clusters, where the first cluster has 2 vertices and the second cluster has 2 vertices. the first vertex has coordinates (0.1, 1.0, 3.2, 9.1) and is adjacent to the second and fourth vertices. the second vertex has coordinates (0.2, 1.1, 3.3, 9.2) and is adjacent to the first and fourth vertices. the third vertex has coordinates (0.3, 1.2, 3.4, 9.3) and is adjacent to the fourth vertex. the fourth vertex has coordinates (0.4, 1.3, 3.5, 9.4) and is adjacent to the first, second and third vertices.

write a python3 code to:
- receive, upon call, number of dimensions (2 or 3), number of classes, number of vertices and spread factor
- generates synthetic n-dimensional data to meet the requested number of classes
- save this data on a new directory under `data`
- plot the data
- run the Gabriel Graph program over the data
- plot the constructed graph
- run the Low Degree Vertices Filter over the data
- plot the filtered graph

the naming and structure format must be kept

`multiVariableGabrielGraph` usage: `{workspace_root}/golden/GabrielGraph/multiVariableGabrielGraph {workspace_root}/data/synthetic/synthetic.csv`
`multiVariableGabrielGraph` output: `{workspace_root}/golden/GabrielGraph/output/synthetic.csv`

`lowDegreeVerticesFilter` usage: `{workspace_root}/golden/LowDegreeVerticesFilter/lowDegreeVerticesFilter {workspace_root}/golden/GabrielGraph/output/synthetic.csv`
`lowDegreeVerticesFilter` output: `{workspace_root}/golden/LowDegreeVerticesFilter/output/synthetic-filtered.csv`

----------------------------------------------------------------------------------------
