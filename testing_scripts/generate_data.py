import numpy as np
import pathlib
from typing import Any, List

def generate_synthetic_data(num_classes: int, num_dimensions: int, num_vertices: int, spread_factor: float, output_file: str, random_seed: int = None, return_centers: bool = False) -> Any:
    """
    Generate synthetic 2D training data with a specified number of vertices and spread factor.
    Each row contains the feature values and a class label. Optionally returns the cluster centers.
    
    Args:
      num_vertices: Total number of vertices to generate.
      spread_factor: Standard deviation for the clusters.
      output_file: File path to save the generated data.
      random_seed: Optional seed for reproducibility.
      return_centers: If True, also return the list of cluster centers.
      
    Returns:
      A numpy array of the generated data, and if return_centers is True, a list of centers.
    """
    if random_seed is not None:
        np.random.seed(random_seed)
    
    base = num_vertices // num_classes
    counts = [base] * num_classes
    for i in range(num_vertices - base * num_classes):
        counts[i] += 1

    data_rows = []
    centers = []
    # Use an explicit mapping for class labels.
    class_labels = [-1, 1]
    
    for label, count in zip(class_labels, counts):
        center = np.random.uniform(0, 10, num_dimensions)
        centers.append(center)
        points = np.random.normal(loc=center, scale=spread_factor, size=(count, num_dimensions))
        for point in points:
            data_rows.append(list(point) + [label])
    
    data_array = np.array(data_rows)
    pathlib.Path(output_file).parent.mkdir(parents=True, exist_ok=True)
    fmt = ("%.6f," * num_dimensions + "%d")
    np.savetxt(output_file, data_array, delimiter=",", fmt=fmt)
    print(f"Synthetic training data saved to {output_file}")
    
    if return_centers:
        return data_array, centers
    else:
        return data_array
    
def generate_to_label_data(num_classes: int, num_dimensions: int, centers: List[np.ndarray], total_num_vertices: int, spread_factor: float, output_file: str, random_seed: int = None) -> np.ndarray:
    """
    Generate synthetic to-label 2D data. The points are generated around the given cluster centers.
    Each row contains only the feature coordinates (no class label).
    
    Args:
      centers: List of cluster centers (as generated by the training data).
      total_num_vertices: Total number of to-label vertices to generate (should be half of training vertices).
      spread_factor: Spread factor for the to-label data.
      output_file: File path to save the generated to-label data.
      random_seed: Optional seed for reproducibility.
      
    Returns:
      A numpy array of the generated to-label data.
    """
    if random_seed is not None:
        # Offset the seed so that the to-label data is different from the training data
        np.random.seed(random_seed + 1)
    
    base = total_num_vertices // num_classes
    counts = [base] * num_classes
    for i in range(total_num_vertices - base * num_classes):
        counts[i] += 1

    data_rows = []
    for center, count in zip(centers, counts):
        points = np.random.normal(loc=center, scale=spread_factor, size=(count, num_dimensions))
        for point in points:
            data_rows.append(list(point))
    
    data_array = np.array(data_rows)
    pathlib.Path(output_file).parent.mkdir(parents=True, exist_ok=True)
    fmt = ("%.6f," * num_dimensions).rstrip(',')
    np.savetxt(output_file, data_array, delimiter=",", fmt=fmt)
    print(f"To-label data saved to {output_file}")
    return data_array
